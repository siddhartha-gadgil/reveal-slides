<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>AI by Autoformalization</title>

	<meta name="description" content="ICTS 2024 summer school lecture">
	<meta name="author" content="Siddhartha Gadgil">

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

	<meta name="viewport"
		content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
	<link rel="stylesheet" href="kwk.css">

	<link rel="icon" href="IIScLogo.jpg">




	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside this container is displayed as a slide -->
		<section class="slides">
			<section data-transition="slide">
				<h2>Accuracy and Scaling for</h2>
				<h2 style="color:#fffdd0">AI for Mathematics</h2>
				<h4>via</h4>
				<h3 style="color:#fffdd0">(Auto)formalization</h3>
				<h4>Siddhartha Gadgil</h4>
				<p>Department of Mathematics</p>
				<p>Indian Institute of Science, Bangalore</p>


			</section>

			<section>
				<ul>
					<li class="fragment">AI systems have shown impressive capabilities in Mathematical reasoning, including a Gold medal score at the IMO, and have become genuinely helpful in mathematical research.</li>
					<li class="fragment">However, they still have (related) limitations:
						<ul>
							<li><strong>Accuracy</strong>.</li>
							<li class="fragment"><strong>Autonomy</strong>: as they need human guidance.</li>
							<li class="fragment"><strong>Scalability</strong>: limited by needing human guidance.</li>
						</ul>
					</li>
					<li class="fragment">An approach is to use a <em>Formal Proof System</em> for verification, and <strong>Autoformalization</strong> as a bridge.</li>
					<li class="fragment">We discuss tools and environments for both <em>Formalization</em> and <em>Mathematical Discovery</em>.</li>
				</ul>
			</section>

			<section data-background="hills.jpg">
				<h1 style="color:#fffdd0">AI for Mathematics</h1>
				<p>&nbsp;</p>
				<h2>A Snapshot</h2>
			</section>


			<section data-background-color="#002b36">
				<h4>IMO Gold for AI</h4>
				<ul>
					<li class="fragment">In IMO 2025, a version of <strong>Gemini DeepThink</strong> got an IMO Gold medal score, following standard timings and graded by the official graders.</li>
					<li class="fragment">Another Gold Medal performance was announced earlier by <strong>OpenAI</strong>.</li>
					<li class="fragment">These were both general purpose reasoning AIs and did not use a formal system for verification.</li>
					<li class="fragment">A Gold medal level performance including <em>formalization in Lean</em> was announced by <strong>Harmonic</strong>.</li>
					<li class="fragment">Another Gold Medal performance was achieved  using an <em>agentic workflow</em> by <strong>Huang-Yang.</strong></li>
			</section>
			<section data-background-color="#002b36">
				<h4>AI for Research Mathematics</h4>
				<ul>
					<li class="fragment">Mathematicians now routinely chat with AI systems.</li>
					<li class="fragment">AI time-to-time proves lemmas the mathematicians failed to prove, gives counterexamples to overoptimistic statements etc.</li>
					<li class="fragment">In some cases, this has led to new mathematics solving open problems.</li>
					<li class="fragment">Typically, the user feels they could have solved the problem themselves. So far, no AI system has produced a <em>mind-boggling</em> proof.</li>
					<li class="fragment">Further, mathematics from AI is often inaccurate.</li>
			</section>

			<section data-background="#002b36">
				<ul>
					<li>Yichen Huang and Lin F. Yang used AI in a loop to solve IMO 2025 problems.</li>
					<img class="fragment" src="IMO-loop.png" alt="Flow for IMO problem solving" height="400px" />
					<li class="fragment">With Gemini-2.5-pro, GPT-5 and Grok-4 they got Gold Medal level scores!</li>
			</ul>

			</section>

			<section data-background-color="#002b36">
				<h4>"Agentic" AI for Research Mathematics</h4>
				<ul>
					<li class="fragment">We would like to have an <em>agentic</em> system, i.e., a system running in loops, for research mathematics.</li>
					<li class="fragment">This will need to be more complex than an IMO system &mdash; for instance will need to study the literature.</li>
					<li class="fragment">While inspecting proofs using LLMs will work to some extent, it is likely that verification by a formal proof system like <em>Lean</em> will be needed.</li>
					<li class="fragment">Lean will also organise accumulating knowledge and give information such as proof failures.</li>
					<li class="fragment">Further, Lean verification will help in acceptance.</li>
			</section>


			<section data-transition="zoom-in slide-out" data-background-image="campus.jpg">
				<h1>LeanAide:</h1>
				<h2>Design and Implementation</h2>
			</section>

			<section data-background-color="teal">
				<ul>
					<li>We want <em>environments</em> and <em>tools</em> for:
						<ul>
							<li>Formalization in Lean using AI.</li>
							<li>Mathematical discovery using AI and Lean, with knowledge of Lean not necessary but usable.</li>
						</ul>
					</li>
					<li class="fragment">These should: 
						<ul>
							<li> <em>Integrate</em> well with workflows.</li>
							<li>Be <em>extensible</em>.</li>
							<li>Be <em>modular</em>, with components replaceable by external ones.</li>
							<li>Be <em>incrementally useful</em>, from occasionally helpful to even fully autonomous.</li>
						</ul>
					</li>
				</ul>
			</section>

			<section data-background-color="teal">
				<h4>Mathematical Reasoning loop</h4>
				<ul>
					<li class="fragment">
						<strong>Problem Deconstruction & Formalization:</strong> Hypothesis and Conclusion, Definitions etc.
					</li>
					<li class="fragment">
						<strong>Problem Inspection:</strong> Easy, Hard, or Study first?
					</li>
					<li class="fragment">
						<strong>Source Material Analysis:</strong> If studying a source first.
					</li>
					<li class="fragment">
						<strong>Strategy & Plan Generation:</strong> Come up with Proof Sketch and Auxiliary Questions.
					</li>
					<li class="fragment">
						<strong>Step-by-step Execution:</strong> Execute the plan.
					</li>
					<li class="fragment">
						<strong>Verification & Critical Analysis:</strong> Verify and critically analyze the results.
					</li>
					<li class="fragment">
						<strong>Meta-cognition and loop control:</strong> Manage the reasoning process and make adjustments.
					</li>
				</ul>
			</section>

						<section data-background-color="teal">
				<h4>Example Queries</h4>
				<ul>
					<li class="fragment">
						While analysing a source:
						<ul>
							<li>List theorems with structure.</li>
							<li>Structural Mapping.</li>
							<li>Stress-test hypothesis: Construct a counterexample without this hypothesis, see where the argument fails.</li>
						</ul>
					</li>
					<li class="fragment">
						While generating a plan:
						<ul>
							<li>Forward reasoning: Consequences of hypotheses.</li>
							<li>Backward reasoning.</li>
							<li>Brainstorm techniques.</li>
							<li>Simplify or specialize the problem.</li>
						</ul>
					</li>
				</ul>
			</section>

			<section data-background-color="teal">
				<h4>Formalization ingredients</h4>
				<ul>
					<li class="fragment">
						Formalize statements and definitions using an LLM given examples with results filtered.
					</li>
					<li class="fragment">
						Generate/Rewrite proofs or documents in a formalization-friendly style.
					</li>
					<li class="fragment">
						Generate a structured JSON representation of the mathematical text according to a formal schema.
					</li>
					<li class="fragment">
						Translate iteratively into Lean code, using:
						<ul>
							<li>Translation of statements and definitions.</li>
							<li>Lean meta-programming to build Lean code from Lean theorems and definitions.</li>
							<li>Automation to complete proofs.</li>
						</ul>
					</li>
				</ul>
			</section>


			<section data-background-video="leanaide-mar25.mp4" data-background-video-muted> </section>

			<section data-background-color="teal">
				<h4>Stages of Mathematical Reasoning loop</h4>
				<ul>
					<li>
						<strong>Problem Deconstruction & Formalization:</strong> Hypothesis and Conclusion, Definitions etc.
					</li>
					<li class="fragment">
						<strong>Problem Inspection:</strong> Easy, Hard, or Study first?
					</li>
					<li class="fragment">
						<strong>Source Material Analysis:</strong> If studying a source first.
					</li>
					<li class="fragment">
						<strong>Strategy & Plan Generation:</strong> Come up with Proof Sketch and Auxiliary Questions.
					</li>
					<li class="fragment">
						<strong>Step-by-step Execution:</strong> Execute the plan.
					</li>
					<li class="fragment">
						<strong>Verification & Critical Analysis:</strong> Verify and critically analyze the results.
					</li>
					<li class="fragment">
						<strong>Meta-cognition and loop control:</strong> Manage the reasoning process and make adjustments.
					</li>
				</ul>
			</section>

	</div>* **Problem Deconstruction & Formalization**
  * Structured Analysis
  * Definition Expansion
  * Rephrasing and Intuition

* **Problem Inspection**
  * Deciding whether to just prove.
  * Deciding whether to first study sources
    * **Branches** either "Source .." or "Problem .."

* **Source Material Analysis**
  * Listing theorems with structure
  * **Loop** through the following:
    * Structural Mapping: Connecting Hypothesis to Conclusion
    * Hypothesis Stress-Testing: The Art of Breaking Things
    * Generalization & Boundary Probing: Pushing the Limits
    * Core Idea Extraction: Finding the "Aha!" Moment

* **Strategy & Plan Generation**
  * Forward reasoning
  * Backward reasoning
  * Technique Brainstorming
  * Simplification & Specialization
  * Proof Sketch & Auxiliary Questions, including labelling auxiliary problems as *easy*, *standard* or *hard*.

* **Step-by-step Execution**
  * Single step execution
    * For a *hard* problem, recursively calls problem solving (with appropriate resource limits).
  * Formal Justification
  * Maintaining State (Summarization)

* **Verification & Critical Analysis**
  * The Skeptic's Hat
  * Sanity Checks and Edge Cases
  * Formalization in Lean and feedback;
    * Itself a many step process, can run in the background.

* **Meta-cognition and loop control**
  * Progress Analysis
  * Identifying Bottlenecks
  * Next Step: one of
    * Refine plan and continue
    * Strategy Pivot to a different plan
    * Changing the main goals (at least for now).
	</div>


<!-- 3. Load Reveal.js -->
<script src="dist/reveal.js"></script>

<!-- 4. Load the Highlight.js plugin for Reveal -->
<script src="plugin/highlight/highlight.js"></script>

	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/math/math.js"></script>

	<script>

		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
			Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,
			hash: true,

			transition: 'slide', // none/fade/slide/concave/concave/zoom


			mathjax2: {
				config: 'TeX-AMS_HTML-full' // See http://docs.mathjax.org/en/latest/config-files.html
			},

			highlight: {
				beforeHighlight: (hljs) => {
					function lean(hljs) {
						const KEYWORDS = {
							$pattern: /\\w+|λ|∀|Π|∃|:=?/u,
							keyword: "theorem|10 lemma|10 definition def class structure instance example inductive coinductive axiom axioms hypothesis constant constants universe universes variable variables parameter parameters begin end infix infixr import open theory prelude renaming hiding exposing calc  match do  by let in extends fun assume #check #eval #reduce #print λ ∀ ∃ Π",
							built_in: "Type Prop|10 Sort rw|10 rewrite rwa erw subst substs simp dsimp simpa simp_intros finish unfold unfold1 dunfold unfold_projs unfold_coes delta cc ac_reflexivity ac_refl existsi|10 cases rcases with intro intros introv by_cases refl rfl funext propext exact exacts refine apply eapply fapply apply_with apply_instance induction rename assumption revert generalize specialize clear contradiction by_contradiction by_contra trivial exfalso symmetry transitivity destruct constructor econstructor left right split injection injections repeat try continue skip swap solve1 abstract all_goals any_goals done fail_if_success success_if_fail guard_target guard_hyp have replace at suffices show from congr congr_n congr_arg norm_num ring ",
							literal: "tt ff",
							meta: "noncomputable|10 private protected meta mutual",
							section: "section namespace end",
							sorry: "sorry admit",
							symbol: ":="
						};
						const COMMENT1 = hljs.COMMENT("--", "$");
						const COMMENT2 = hljs.COMMENT("/-[^-]", "-/");
						const THEOREM = {
							className: "theorem",
							beginKeywords: "def theorem lemma class instance structure",
							end: /:=/,
							excludeEnd: true,
							contains: [{
								className: "keyword",
								begin: /extends/,
								contains: [{
									className: "symbol",
									begin: /:=/,
									endsParent: true
								}]
							}, hljs.inherit(hljs.TITLE_MODE, {
								begin: /[A-Za-z_][\\w\u207F-\u209C\u1D62-\u1D6A\u2079']*/
							}), {
								className: "params",
								begin: /[([{]/,
								end: /[)\]}]/,
								endsParent: false,
								keywords: KEYWORDS
							}, {
								className: "symbol",
								begin: /:=/,
								endsParent: true
							}, {
								className: "symbol",
								begin: /:/,
								endsParent: true
							}],
							keywords: KEYWORDS
						};
						return {
							name: "lean",
							keywords: KEYWORDS,
							contains: [
								hljs.QUOTE_STRING_MODE,
								hljs.NUMBER_MODE,
								COMMENT1,
								COMMENT2,
								{
									className: "doctag",
									begin: "/-[-!]",
									end: "-/"
								},
								THEOREM,
								{
									className: "meta",
									begin: "@\\[",
									end: "\\]"
								}, {
									className: "meta",
									begin: "^attribute",
									end: "$"
								}, {
									begin: /\u27e8/
								}
							]
						};
					}
					hljs.registerLanguage('lean', lean);
				}
			},

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [
				RevealMarkdown,
				RevealHighlight,
				RevealNotes,
				RevealMath.MathJax2
			]
		});

	</script>

</body>

</html>