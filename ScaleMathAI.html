<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>AI by Autoformalization</title>

	<meta name="description" content="ICTS 2024 summer school lecture">
	<meta name="author" content="Siddhartha Gadgil">

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

	<meta name="viewport"
		content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
	<link rel="stylesheet" href="kwk.css">

	<link rel="icon" href="IIScLogo.jpg">




	<style>
		.hljs-built_in {
		  color: #8be9fd !important;
		}
		</style>

	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside this container is displayed as a slide -->
		<section class="slides">
			<section data-transition="slide">
				<h2>Accuracy and Scaling for</h2>
				<h2 style="color:#fffdd0">AI for Mathematics</h2>
				<h4>via</h4>
				<h3 style="color:#fffdd0">(Auto)formalization</h3>
				<h4>Siddhartha Gadgil</h4>
				<p>Department of Mathematics</p>
				<p>Indian Institute of Science, Bangalore</p>


			</section>

			<section>
				<ul>
					<li>AI systems have shown impressive capabilities in Mathematical reasoning, including a Gold medal score at the IMO, and have become genuinely helpful in mathematical research.</li>
					<li class="fragment">However, they still have (related) limitations:
						<ul>
							<li class="fragment"><strong>Accuracy</strong>: in mathematics errors cascade.</li>
							<li class="fragment"><strong>Autonomy</strong>: as they need human verification.</li>
							<li class="fragment"><strong>Scalability</strong>: limited by needing human guidance.</li>
						</ul>
					</li>
					<li class="fragment">An approach is to use a <em>Formal Proof System</em> for verification, and <strong>Autoformalization</strong> as a bridge.</li>
					<li class="fragment">We discuss tools and environments for both <em>Formalization</em> and <em>Mathematical Discovery</em>.</li>
				</ul>
			</section>

			<section data-background="hills.jpg">
				<h1 style="color:#fffdd0">AI for Mathematics</h1>
				<p>&nbsp;</p>
				<h2>A Snapshot</h2>
			</section>


			<section data-background-color="#002b36">
				<h4>IMO Gold for AI</h4>
				<ul>
					<li class="fragment">In IMO 2025, a version of <strong>Gemini DeepThink</strong> got an IMO Gold medal score, following standard timings and graded by the official graders.</li>
					<li class="fragment">Another Gold Medal performance was announced earlier by <strong>OpenAI</strong>.</li>
					<li class="fragment">These were both general purpose reasoning AIs and did not use a formal system for verification.</li>
					<li class="fragment">A Gold medal level performance including <em>formalization in Lean</em> was announced by <strong>Harmonic</strong>.</li>
					<li class="fragment">Another Gold Medal performance was achieved  using an <em>agentic workflow</em> by <strong>Huang-Yang.</strong></li>
			</section>

			<section data-background-color="#002b36">
				<h4>Some more advanced problems</h4>
				<ul>
					<li class="fragment">Suppose $f: \mathbb{R} \to\mathbb{R}$ is a smooth function such the $f''(x)>0$ for all $x\in\mathbb{R}$, then $f$ is not bounded above.</li>
					<li class="fragment">Suppose $X$, $Y$ and $Z$ are independent random variables such that $X\sim N(1,1)$, $Y\sim Beta(2,2)$ and $Z\sim Uniform[0,3]$. Find $P(X+Y>Z)$.</li>
					<li class="fragment">Find all $2 \times 2$ matrices with rational entries such that $A^5 = I$.</li>
					<li class="fragment">Models up to GPT-4 struggled with these questions, but today's models can solve them.</li>
			</section>


			<section data-background-color="#002b36">
				<h4>AI for Research Mathematics</h4>
				<ul>
					<li class="fragment">Mathematicians now routinely chat with AI systems.</li>
					<li class="fragment">AI systems time-to-time prove lemmas the mathematicians failed to prove, give counterexamples to overoptimistic statements etc.</li>
					<li class="fragment">In some cases, this has led to new mathematics solving open problems.</li>
					<li class="fragment">Typically, the user feels they could have solved the problem themselves. <span class="fragment">So far, probably no AI system has produced a <em>mind-boggling</em> proof.</span></li>
					<li class="fragment">Further, mathematics from AI is often inaccurate.</li>
			</section>
			
			<section data-background-color="#002b36">
				<h4>AI Systems for special problems</h4>
				<ul>
					<li class="fragment">Often the core of a mathematical result is a special problem or construction.</li>
					<li class="fragment">For example, Viazovska's work on sphere-packing problem relies on the construction of a "magic" special function using the theory of modular forms.</li>
					<li class="fragment">Similarly, an entropy function had a crucial role in Perelman's work on the Poincaré conjecture.</li>
					<li class="fragment"> AI Systems like <em>AlphaEvolve</em> and <em>PatternBoost</em> allow construction of such functions.</li>
					<li class="fragment">Systems like <em>SAT/SMT Solvers</em> and <em>Resolution Theorem Provers</em> can also solve special problems.</li>
			</section>

			<section data-background="#002b36">
				<ul>
					<li>Yichen Huang and Lin F. Yang used AI in a loop to solve IMO 2025 problems.</li>
					<img class="fragment" src="IMO-loop.png" alt="Flow for IMO problem solving" height="400px" />
					<li class="fragment">With Gemini-2.5-pro, GPT-5 and Grok-4 they got Gold Medal level scores!</li>
			</ul>

			</section>

			<section data-background-color="#002b36">
				<h4>"Agentic" AI for Research Mathematics</h4>
				<ul>
					<li class="fragment">We would like to have an <em>agentic</em> system, i.e., a system running in loops, for research mathematics.</li>
					<li class="fragment">This will need to be more complex than an IMO system &mdash; for instance we study the literature.</li>
					<li class="fragment">While inspecting proofs using LLMs will work to some extent, it is likely that verification by a formal proof system like <em>Lean</em> will be needed.</li>
					<li class="fragment">Lean will also organise accumulating knowledge and give information such as proof failures.</li>
					<li class="fragment">Further, Lean verification will help in acceptance.</li>
					<li class="fragment">AI is likely to generate better ideas this way.</li>
			</section>


			<section data-transition="zoom-in slide-out" data-background-image="campus.jpg">
				<h1>LeanAide:</h1>
				<h2>Design and Implementation</h2>
			</section>

			<section data-background-color="teal">
				<ul>
					<li>We want <em>environments</em> and <em>tools</em> for:
						<ul>
							<li>Formalization in Lean using AI.</li>
							<li>Mathematical discovery using AI and Lean, with knowledge of Lean not necessary but usable.</li>
						</ul>
					</li>
					<li class="fragment">These should have the following features: 
						<ul>
							<li> <em>Integrate</em> well with workflows.</li>
							<li><em>Extensibility</em>.</li>
							<li><em>Modularity</em>, with components replaceable.</li>
							<li><em>Incremental usefulness</em>, from occasionally helpful to even fully autonomous.</li>
							<li><em>Interactivity</em>, allowing users to guide and interact with the system.</li>
						</ul>
					</li>
				</ul>
			</section>

			<section data-background-color="teal">
				<h4>Mathematical Reasoning loop</h4>
				<ul>
					<li class="fragment">
						<strong>Problem Deconstruction & Formalization:</strong> Hypothesis and Conclusion, Definitions etc.
					</li>
					<li class="fragment">
						<strong>Problem Inspection:</strong> Easy, Hard, or Study first?
					</li>
					<li class="fragment">
						<strong>Source Material Analysis:</strong> If studying a source first.
					</li>
					<li class="fragment">
						<strong>Strategy & Plan Generation:</strong> Come up with Proof Sketch and Auxiliary Questions.
					</li>
					<li class="fragment">
						<strong>Step-by-step Execution:</strong> Execute the plan.
					</li>
					<li class="fragment">
						<strong>Verification, Formalization & Critical Analysis</strong>.
					</li>
					<li class="fragment">
						<strong>Meta-cognition and loop control:</strong> Manage the reasoning process and make adjustments.
					</li>
					<li class="fragment">LLM Steps: <em>prompt templates</em> and <em>output schemas</em>.</li>
				</ul>
			</section>

			<section data-background-color="teal">
				<h4>Example Queries</h4>
				<ul>
					<li class="fragment">
						While analysing a source:
						<ul>
							<li>List theorems with structure.</li>
							<li>Structural Mapping: What is used where.</li>
							<li>Stress-test hypothesis: Construct a counterexample without this hypothesis, see where the argument fails.</li>
						</ul>
					</li>
					<li class="fragment">
						While generating a plan:
						<ul>
							<li>Forward reasoning: Consequences of hypotheses.</li>
							<li>Backward reasoning.</li>
							<li>Brainstorm techniques.</li>
							<li>Simplify or specialize the problem.</li>
						</ul>
					</li>
				</ul>
			</section>

			<section data-background-color="teal">
				<h4>AutoFormalization: Ingredients and Stages</h4>
				<ul>
					<li class="fragment">
						Formalize statements and definitions using an LLM given examples with results filtered (<em>local step</em>).
					</li>
					<li class="fragment">
						Generate/Rewrite proofs or documents in a formalization-friendly style.
					</li>
					<li class="fragment">
						Generate a structured JSON representation of the mathematical text according to a formal schema.
					</li>
					<li class="fragment">
						Translate iteratively into Lean code, using:
						<ul>
							<li class="fragment">Translation of statements and definitions.</li>
							<li class="fragment">Lean meta-programming to build Lean code from Lean theorems and definitions.</li>
							<li class="fragment">Automation to complete proofs.</li>
						</ul>
					</li>
				</ul>
			</section>


			<section data-background-video="leanaide-mar25.mp4" data-background-video-muted> </section>

			<section data-background-color="teal">
				<h4>Example: Formalizing a simple theorem</h4>
				<ul>
					<li><strong>Theorem:</strong> Let $(a_n)$ be a sequence defined by $a_0=c$ and $a_{n+1} = a_n$ for all $n$.
Then $a_n = c$ for all $n$.</li>
					<li><strong>Proof:</strong> (LLM Generated)<ul>
					<li>By induction</li>
					<li>Base case: $a_0=c$ by definition.</li>
					<li>Inductive step: if $a_n=c$, then $a_{n+1}=a_n=c$.</li>
					<li>Thus $a_n=c$ for all $n$.</li>
					</ul></li>
					<ul>
						


				</ul>
			</section>
			<section data-background-color="teal">
				<h4>Formalized Theorem JSON Representation</h4>
				<pre><code class="language-json">{
  "document": {
    "type": "document",
    "body": [
      {
        "type": "Theorem",
        "header": "Theorem",
        "label": "thm:constant_sequence",
        "hypothesis": [
          {
            "type": "let_statement",
            "variable_name": "(a_n)",
            "statement": "Let $(a_n)$ be a sequence 
			defined by $a_0=c$ and $a_{n+1} = a_n$ for all $n$."
          }
        ],
        "claim": "$a_n = c$ for all $n$.",
        "proof": [
          {
            "type": "induction_proof",
            "on": "n",
            "base_case_proof": [
              {
                "type": "assert_statement",
                "claim": "$a_0 = c$",
                "proof_method": "by definition"
              }
            ],
            "induction_step_proof": [
              {
                "type": "assume_statement",
                "assumption": "Assume $a_n = c$."
              },
              {
                "type": "calculation",
                "inline_calculation": "a_{n+1} = a_n = c",
                "calculation_sequence": [
                  "a_{n+1} = a_n",
                  "= c"
                ]
              }
            ]
          },
          {
            "type": "conclude_statement",
            "claim": "Thus $a_n = c$ for all $n$."
          }
        ]
      }
    ]
  }
}
</code></pre> </section>

<section data-background-color="teal">
	<h4>Formalized Theorem in Lean</h4>
	<pre>
<code class="language-lean">theorem constant_seq_eq_of_const_init :
      ∀ {α : Type u} (c : α) (a : ℕ → α),
        a 0 = c → (∀ (n : ℕ), a (n + 1) = a n) → 
			∀ (n : ℕ), a n = c :=
    by
    intro α c a a_18193650970466190054 a_18068984259474765511 n
    induction n with
    | zero =>
      grind only
    | succ n ih =>
      grind only
    done
	</code>
	</pre>
</section>


			<section data-background-color="teal">
				<h4>Example: Case Analysis</h4>
				<pre><code class="language-json">"theorem" : {
"claim" : "∀ n : ℕ, n = 1  ∨ n = 2 → n < 3",
"proof" : {"multi-condition_cases_proof" : {
	"on" : "n",
	"proof_cases" : [
	{"condition" : "n = 1", "proof" : []},
	{"condition" : "n = 2", "proof" : []}
	]}}}</code>
<code class="language-lean">theorem nat_eq_one_or_eq_two_imp_lt_three : ∀ (n : ℕ), 
			n = 1 ∨ n = 2 → n < 3 := by
    intro n a_12668439849020315063
    if condition_15952715909003343985 : n = 1 then
      grind only
    else
      if condition_1530173634913780371 : n = 2 then
        grind only
      else
        grind only
    done
	</code></pre> </section>

	<section data-background-color="teal">
		<h4>Implementation of Autoformalization</h4>
		<ul>
			<li class="fragment">Autoformalization of statements/definitions is done by finding and adding related examples to the prompt and filtering by <em>elaboration</em>.</li>
			<li class="fragment">The translation from JSON to Lean code is done by recursively calling functions with an <em>attribute</em> adding them to an <em>environment extension</em>.
		<pre><code class="language-lean">@[codegen "induction_proof"]
def inductionCode (translator : CodeGenerator := {}) : 
	Option MVarId →  (kind: SyntaxNodeKinds) → Json → 
		TranslateM (Option (TSyntax kind))
| some goal, ``tacticSeq, js => ...</code></pre>
			</li>
			<li class="fragment">The JSON schema is similarly extensible.</li>
		</ul>
	</section>

	<section data-background-color="teal">
		<h4>Improving Autoformalization</h4>
		<ul>
			<li class="fragment">For failures in translation of statements/definitions, we can recognize errors and fix in Lean (for example <code>∃! x y : Nat, ...</code>) or with LLM help (for example <code>∃ [G: Group], ...</code>).
			</li>
			<li class="fragment">For documents,we must recognize common names, and also extract variables from existence claims etc. </li>
			<li class="fragment">In case automation cannot complete proofs, we can iterate with LLM queries that may be refined (example for the <code>use</code> tactic). </li>
			<li class="fragment">We should refine the schema and implement code generators for better handling calculations etc.</li>
		</ul>
	</section>

			<section data-background-color="teal">
				<ul>
					<li>
						LeanAide can be used from within Lean using its syntax, <code>TryThis</code> widgets etc.
					</li>
					<li class="fragment">
						A server-client architecture means only a single dependency-free Lean dependency is needed. 
					</li>
					<li class="fragment">
						We also (will) have web clients and bots.
					</li>
					<li class="fragment">
						Specifically, we will have a chat and canvas interface to LLMs, with query-templates, autoformalization etc to help in mathematical discovery.
					</li>
					<li class="fragment">How much value is added by incorporating LeanAide will depend on the quality of autoformalization.</li>
					<li class="fragment">Many improvements will be free &ndash; better AI and better automation in Lean &#x1F600;.</li>
				</ul>
			</section>

	</div>
	</div>


<!-- 3. Load Reveal.js -->
<script src="dist/reveal.js"></script>

<!-- 4. Load the Highlight.js plugin for Reveal -->
<script src="plugin/highlight/highlight.js"></script>

	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/math/math.js"></script>

	<script>

		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
			Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,
			hash: true,

			transition: 'slide', // none/fade/slide/concave/concave/zoom


			mathjax2: {
				config: 'TeX-AMS_HTML-full' // See http://docs.mathjax.org/en/latest/config-files.html
			},

						highlight: {
							beforeHighlight: (hljs) => {
								function lean(hljs) {
									const KEYWORDS = {
										$pattern: /\\w+|λ|∀|Π|∃|:=?/u,
										keyword: "theorem|10 lemma|10 definition def class structure instance example inductive coinductive axiom axioms hypothesis constant constants universe universes variable variables parameter parameters begin end infix infixr import open theory prelude renaming hiding exposing calc  match do  by let in extends fun assume #check #eval #reduce #print λ ∀ ∃ Π",
										built_in: "Type Prop|10 Sort rw|10 rewrite rwa erw subst substs simp dsimp simpa simp_intros finish unfold unfold1 dunfold unfold_projs unfold_coes delta cc ac_reflexivity ac_refl existsi|10 cases rcases with intro intros introv by_cases refl rfl funext propext exact exacts refine apply eapply fapply apply_with apply_instance induction rename assumption revert generalize specialize clear contradiction by_contradiction by_contra trivial exfalso grind by only symmetry transitivity destruct constructor econstructor left right split injection injections repeat try continue skip swap solve1 abstract all_goals any_goals done fail_if_success success_if_fail guard_target guard_hyp have replace at suffices show from congr congr_n congr_arg norm_num ring ",
										literal: "tt ff",
										meta: "noncomputable|10 private protected meta mutual",
										section: "section namespace end",
										sorry: "sorry admit",
										symbol: ":="
									};
									const COMMENT1 = hljs.COMMENT("--", "$");
									const COMMENT2 = hljs.COMMENT("/-[^-]", "-/");
									const THEOREM = {
										className: "theorem",
										beginKeywords: "def theorem lemma class instance structure",
										end: /:=/,
										excludeEnd: true,
										contains: [{
											className: "keyword",
											begin: /extends/,
											contains: [{
												className: "symbol",
												begin: /:=/,
												endsParent: true
											}]
										}, hljs.inherit(hljs.TITLE_MODE, {
											begin: /[A-Za-z_][\\w\u207F-\u209C\u1D62-\u1D6A\u2079']*/
										}), {
											className: "params",
											begin: /[([{]/,
											end: /[)\]}]/,
											endsParent: false,
											keywords: KEYWORDS
										}, {
											className: "symbol",
											begin: /:=/,
											endsParent: true
										}, {
											className: "symbol",
											begin: /:/,
											endsParent: true
										}],
										keywords: KEYWORDS
									};
			
									const BUILT_IN_WORDS = KEYWORDS.built_in.replace(/\|10/g, '').trim().split(' ').join('|');
			
									return {
										name: "lean",
										keywords: KEYWORDS,
										contains: [
											{
												className: 'built_in',
												begin: '\\b(' + BUILT_IN_WORDS + ')\\b'
											},
											hljs.QUOTE_STRING_MODE,
											hljs.NUMBER_MODE,
											COMMENT1,
											COMMENT2,
											{
												className: "doctag",
												begin: "/-[-!]",
												end: "-/"
											},
											THEOREM,
											{
												className: "meta",
												begin: "@\\[",
												end: "\\]"
											}, {
												className: "meta",
												begin: "^attribute",
												end: "$"
											}, {
												begin: /\u27e8/
											}
										]
									};
								}
								hljs.registerLanguage('lean', lean);
							}
						},
			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [
				RevealMarkdown,
				RevealHighlight,
				RevealNotes,
				RevealMath.MathJax2
			]
		});

	</script>

</body>

</html>